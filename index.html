<style>
    * {
        font-family: sans-serif;
    }
    body {
        background: linear-gradient(312deg, #364960, #81848c);
    }
    button {
        background: linear-gradient(45deg, #1e1e1e, transparent);
        border: 1px solid #4c4c4c;
        filter: drop-shadow(0 2px 2px #2e2e2e);
        padding: 5px 10px;
        color: #d9d9d9;
        border-radius: 8px;
        cursor: pointer;
        margin: 3px;
    }
    table,
    td,
    tr {
        border: 0;
    }
    td {
        width: 16.6667%;
    }
    table {
        border-collapse: collapse;
        width: 60%;
        margin: 0 auto;
        margin-top: 6px;
    }
    .r {
        text-align: right;
        color: #e0e0e0;
        font-size: 12px;
        font-family: monospace;
    }
    #app {
        max-width: 630px;
        background: #fff;
        padding: 30px;
        margin: 50px auto;
        border-radius: 15px;
        filter: drop-shadow(0 4px 6px #00000077);
        text-align: center;
        color: #fff;
        background: linear-gradient(45deg, #111, #3d3d3d);
        color: #848484;
        font-size: 12px;
    }
    #appcont {
        position: relative;
        zoom: 0.6;
        width: 800px;
        height: 480px;
        margin: 0 auto;
    }
    #radd {
        margin: 8px;
    }
    #wlogo {
        margin: 14px;
        filter: invert(1);
        opacity: 0.5;
    }
    #ssvvgg {
        position: absolute;
        top: 0;
        left: 0;
    }
    canvas {
        border: 1px solid #3b3b3b;
    }
</style>
<div id="app">
    <button onclick="connect()" style="width: 100%">Подключить устройство</button><br /><input
        type="radio"
        id="radd"
    /><br />
    <div id="appcont">
        <canvas id="myCanvas" width="800" height="480"></canvas>
        <svg width="800" height="480" id="ssvvgg"></svg>
    </div>
    <button onclick="saveSvg(ssvvgg,'firma.svg')">Сохранить в SVG</button><br />
    <button onclick="clearscreen()">Очистить</button>
    <button onclick="img.src='wacom.png'; sendimage()">Режим подписи</button><br />
    <table>
        <tbody>
            <tr>
                <td class="r">Фон</td>
                <td>
                    <input id="colo" value="#ffffff" type="color" onchange="changebackground()" />
                </td>
                <td class="r">Яркость</td>
                <td>
                    <input
                        id="brig"
                        value="1"
                        min="0"
                        max="3"
                        step="1"
                        type="range"
                        onchange="adjustbrigtness()"
                    />
                </td>
                <td class="r">Рисуем?</td>
                <td><input type="checkbox" id="imod" onchange="inkmode()" checked /></td>
            </tr>
            <tr>
                <td class="r">Цвет пера</td>
                <td><input id="cola" value="#000" type="color" onchange="changepen()" /></td>
                <td class="r">Жирность</td>
                <td>
                    <input
                        id="pens"
                        value="1"
                        min="0"
                        max="5"
                        step="1"
                        type="range"
                        onchange="changepen()"
                    />
                </td>
            </tr>
        </tbody>
    </table>
    <br /><br />
</div>

<script src="wacomstu540.js"></script>
<script>
    // DEMO APP

    //Wacom tablet object
    var wacom = new wacomstu540();

    //Defs
    var image;
    var poly;
    var pen_state = false;
    var imgreq = false;
    var lastPressure = 0.0;

    //Canvas stuff, used to create images and get it pixels
    var canvas = document.getElementById('myCanvas');
    var context = myCanvas.getContext('2d');
    var img = new Image();

    //Check for wacom tab connected now
    wacom.checkAvailable().then(function (supp) {
        if (!supp) app.style.opacity = 0.3;
    });

    //Add hid listeners
    wacom.onHidChange(function (e) {
        if (e == 'connect') app.style.opacity = 1;
        else {
            wacom.device = null;
            app.style.opacity = 0.3;
        }
    });

    //Connect and setup initial state and events
    async function connect() {
        if (await wacom.connect()) {
            await wacom.clearScreen();
            //await wacom.setBackgroundColor(colo.value)
            await wacom.setPenColorAndWidth(cola.value, pens.value);
            await wacom.setWritingMode(1);
            await wacom.setWritingArea({ x1: 0, y1: 0, x2: 800, y2: 480 });
            await wacom.setInking(true);
            wacom.onPenData(function (pen) {
                pointevent(pen.press > 0 && imod.checked, pen.cx, pen.cy, pen.press);
            });
            clearscreen();
        }
    }

    //Control actions

    async function inkmode() {
        await wacom.setInking(imod.checked == 1);
    }
    async function writingmode() {
        await wacom.setWritingMode(wmod.checked == 1 ? 1 : 0);
    }
    async function clearscreen() {
        await wacom.clearScreen();
        context.fillStyle = colo.value;
        context.fillRect(0, 0, canvas.width, canvas.height);
        ssvvgg.innerHTML = '';
    }
    async function changebackground() {
        await wacom.setBackgroundColor(colo.value);
        await clearscreen();
    }
    async function adjustbrigtness() {
        console.log('do not call this often');
        await wacom.setBacklight(brig.value);
    }
    async function changepen() {
        await wacom.setPenColorAndWidth(cola.value, pens.value);
    }
    async function sendimage() {
        await wacom.setImage(image);
        imgreq = false;
        ssvvgg.innerHTML = '';
        await inkmode();
    }

    //Pressure ink rendering helpers

    //Obtain difference between 2 numbers
    function pressdiff(a, b) {
        if (a > b) return a - b;
        else return b - a;
    }
    //Transform stroke according the pressure level
    function makestroke(v) {
        let pf = lastPressure + 0.5; //Shift scale (0.5-1.5) so it does magnification and reduction
        return Math.max(v * pf, 0.5); //Ensure some width on the product
    }
    //Add a polyline to the chain
    function addpoly() {
        poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        poly.setAttributeNS(
            null,
            'style',
            'fill:none;stroke:' +
                cola.value +
                ';stroke-width:' +
                makestroke(parseInt(pens.value) + 1) +
                ';'
        );
        ssvvgg.append(poly);
    }
    //Adds a point to the last polyline
    function polypoint(x, y) {
        var point = ssvvgg.createSVGPoint();
        point.x = x;
        point.y = y;
        poly.points.appendItem(point);
    }

    //Pen event handler
    async function pointevent(z, x, y, p) {
        // State just changed?
        if (z != pen_state) {
            if (z) {
                addpoly();
                //Handle repeat "button" zone
                if (x > 580 && y < 50 && !imgreq) {
                    //Disable inking and load bg image, inking is reenabled on image load
                    await wacom.setInking(false);
                    setTimeout(sendimage, 10);
                    imgreq = true;
                }
            } else polypoint(x, y); //Finish the pointlist
            pen_state = z;
        }
        //Is touching screen?
        if (z) {
            //check if need to create new polyline with better fit stroke
            if (pressdiff(p, lastPressure) > 0.02) {
                //Add a connection point to the last polyline
                polypoint(x, y);
                lastPressure = p;
                addpoly();
            }
            //Add the point to the polyline
            polypoint(x, y);
        }
    }

    //Callback for image loading. Manipulates the image and converts to 24.BGR from stretched canvas
    async function loadImg() {
        context.drawImage(img, 0, 0, 800, 480);
        if (!img.src.includes('wacom.png')) {
            //Unrestrict inking area
            await wacom.setWritingArea({ x1: 0, y1: 0, x2: 800, y2: 480 });
        } else {
            //Restrict inking area
            await wacom.setWritingArea({ x1: 16, y1: 50, x2: 800 - 16, y2: 480 - 16 });
            //Add text to image
            context.font = '22px Arial';
            var date = new Date().toLocaleString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
            });
            context.fillText('Signed in XXXXXXXX at ' + date, 130, 450);
        }
    }

    //Helper to download the signature SVG
    function saveSvg(svgEl, name) {
        svgEl.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        var svgData = svgEl.outerHTML;
        var preface = '<?xml version="1.0" standalone="no"?>\r\n';
        var svgBlob = new Blob([preface, svgData], { type: 'image/svg+xml;charset=utf-8' });
        var svgUrl = URL.createObjectURL(svgBlob);
        var downloadLink = document.createElement('a');
        downloadLink.href = svgUrl;
        downloadLink.download = name;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    }
</script>
